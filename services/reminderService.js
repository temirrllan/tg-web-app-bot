const cron = require('node-cron');
const db = require('../config/database');

class ReminderService {
  constructor(bot) {
    this.bot = bot;
    this.tasks = new Map();
    this.isRunning = false;
    console.log('üîî ReminderService initialized');
  }

  start() {
    if (this.isRunning) {
      console.log('‚ö†Ô∏è Reminder service is already running');
      return;
    }

    console.log('üîî Starting reminder service...');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
    const task = cron.schedule('* * * * *', async () => {
      await this.checkAndSendReminders();
    }, {
      scheduled: true,
      timezone: process.env.TZ || "UTC" // –ò—Å–ø–æ–ª—å–∑—É–µ–º —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
    });
    
    this.tasks.set('main', task);
    this.isRunning = true;
    console.log('‚úÖ Reminder service started - checking every minute');
    console.log(`üìç Timezone: ${process.env.TZ || 'UTC'}`);
    
    // –°—Ä–∞–∑—É –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
    setTimeout(() => this.checkAndSendReminders(), 5000);
  }

  async checkAndSendReminders() {
    try {
      const now = new Date();
      const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:00`;
      const currentDay = now.getDay() || 7; // 0 (Sunday) = 7
      const today = now.toISOString().split('T')[0];
      
      console.log(`üïê Checking reminders: ${currentTime}, Day: ${currentDay} (${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][now.getDay()]})`);
      
      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø—Ä–∏–≤—ã—á–∫–∏ —Å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º–∏ –Ω–∞ —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
      const result = await db.query(
        `SELECT 
          h.id,
          h.title,
          h.goal,
          h.reminder_time,
          h.schedule_days,
          u.telegram_id,
          u.first_name,
          u.language
         FROM habits h
         JOIN users u ON h.user_id = u.id
         WHERE h.reminder_enabled = true
         AND h.reminder_time = $1
         AND h.is_active = true
         AND $2 = ANY(h.schedule_days)`,
        [currentTime, currentDay]
      );
      
      if (result.rows.length > 0) {
        console.log(`üì® Found ${result.rows.length} habits with reminders at ${currentTime}`);
        
        for (const habit of result.rows) {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≤—ã—á–∫–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
          const statusResult = await db.query(
            `SELECT status FROM habit_marks 
             WHERE habit_id = $1 
             AND date = $2::date`,
            [habit.id, today]
          );
          
          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
          let shouldSendReminder = true;
          let reminderReason = 'pending';
          
          if (statusResult.rows.length > 0) {
            const currentStatus = statusResult.rows[0].status;
            console.log(`üìä Habit "${habit.title}" (ID: ${habit.id}) status: ${currentStatus}`);
            
            // –õ–æ–≥–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞
            switch(currentStatus) {
              case 'completed':
                shouldSendReminder = false;
                console.log(`‚úÖ Habit already completed - skipping reminder`);
                break;
              case 'failed':
                shouldSendReminder = false;
                console.log(`‚ùå Habit marked as failed - skipping reminder`);
                break;
              case 'skipped':
                shouldSendReminder = true;
                reminderReason = 'skipped';
                console.log(`‚è≠ Habit was skipped - sending reminder again`);
                break;
              case 'pending':
              default:
                shouldSendReminder = true;
                reminderReason = 'pending';
                console.log(`‚è∞ Habit is pending - sending reminder`);
                break;
            }
          } else {
            // –ù–µ—Ç –æ—Ç–º–µ—Ç–∫–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
            shouldSendReminder = true;
            reminderReason = 'no_mark';
            console.log(`üìù No mark for today - sending reminder`);
          }
          
          if (shouldSendReminder) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ –ª–∏ —É–∂–µ —Å–µ–≥–æ–¥–Ω—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
            // (–¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∏–∑ completed/failed –≤ skipped)
            const sentToday = await db.query(
              `SELECT id, sent_at FROM reminder_history 
               WHERE habit_id = $1 
               AND DATE(sent_at) = CURRENT_DATE
               ORDER BY sent_at DESC
               LIMIT 1`,
              [habit.id]
            );
            
            // –ï—Å–ª–∏ –ø—Ä–∏–≤—ã—á–∫–∞ –±—ã–ª–∞ –≤ skipped, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
            if (sentToday.rows.length > 0 && reminderReason === 'skipped') {
              const lastSentTime = new Date(sentToday.rows[0].sent_at);
              const timeDiff = now - lastSentTime;
              const minutesDiff = Math.floor(timeDiff / 60000);
              
              // –ï—Å–ª–∏ –ø—Ä–æ—à–ª–æ –º–µ–Ω—å—à–µ 60 –º–∏–Ω—É—Ç —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
              if (minutesDiff < 60) {
                console.log(`‚è∞ Already sent reminder ${minutesDiff} minutes ago for skipped habit - skipping`);
                continue;
              }
            } else if (sentToday.rows.length > 0 && reminderReason !== 'skipped') {
              // –î–ª—è –æ–±—ã—á–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π - –æ–¥–Ω–æ –≤ –¥–µ–Ω—å
              console.log(`‚è≠ Already sent reminder for habit "${habit.title}" today`);
              continue;
            }
            
            await this.sendReminder(habit, reminderReason);
            // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Error checking reminders:', error.message);
      console.error(error.stack);
    }
  }

  async sendReminder(habit, reason = 'pending') {
    try {
      const chatId = habit.telegram_id;
      const lang = habit.language || 'en';
      
      console.log(`üì§ Sending reminder to ${chatId} for habit "${habit.title}" (reason: ${reason})`);
      
      // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∏—á–∏–Ω—ã
      let message;
      
      if (reason === 'skipped') {
        // –û—Å–æ–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –ø—Ä–∏–≤—ã—á–µ–∫
        message = lang === 'ru' 
          ? `üîî <b>–ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!</b>

üìù <b>–ü—Ä–∏–≤—ã—á–∫–∞:</b> ${habit.title}
üéØ <b>–¶–µ–ª—å:</b> ${habit.goal}
‚è∞ <b>–í—Ä–µ–º—è:</b> ${habit.reminder_time ? habit.reminder_time.substring(0, 5) : '—Å–µ–π—á–∞—Å'}

–í—ã –ø—Ä–æ–ø—É—Å—Ç–∏–ª–∏ —ç—Ç—É –ø—Ä–∏–≤—ã—á–∫—É —Å–µ–≥–æ–¥–Ω—è. –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–∑–¥–Ω–æ –Ω–∞—á–∞—Ç—å —Å–Ω–æ–≤–∞! üí™
–ö–∞–∂–¥—ã–π –º–æ–º–µ–Ω—Ç - —ç—Ç–æ –Ω–æ–≤–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å!`
          : `üîî <b>Reminder Again!</b>

üìù <b>Habit:</b> ${habit.title}
üéØ <b>Goal:</b> ${habit.goal}
‚è∞ <b>Time:</b> ${habit.reminder_time ? habit.reminder_time.substring(0, 5) : 'now'}

You skipped this habit today. It's never too late to start again! üí™
Every moment is a new opportunity!`;
      } else {
        // –û–±—ã—á–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
        message = lang === 'ru' 
          ? `üîî <b>–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –ø—Ä–∏–≤—ã—á–∫–µ!</b>

üìù <b>–ü—Ä–∏–≤—ã—á–∫–∞:</b> ${habit.title}
üéØ <b>–¶–µ–ª—å:</b> ${habit.goal}
‚è∞ <b>–í—Ä–µ–º—è:</b> ${habit.reminder_time ? habit.reminder_time.substring(0, 5) : '—Å–µ–π—á–∞—Å'}

–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ—Ç–º–µ—Ç–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ:`
          : `üîî <b>Habit Reminder!</b>

üìù <b>Habit:</b> ${habit.title}
üéØ <b>Goal:</b> ${habit.goal}
‚è∞ <b>Time:</b> ${habit.reminder_time ? habit.reminder_time.substring(0, 5) : 'now'}

Don't forget to mark your progress:`;
      }
      
      // –ö–Ω–æ–ø–∫–∏ –¥–ª—è –æ—Ç–º–µ—Ç–∫–∏
      const keyboard = {
        inline_keyboard: [
          [
            { text: '‚úÖ Done', callback_data: `mark_done_${habit.id}` },
            { text: '‚è≠ Skip', callback_data: `mark_skip_${habit.id}` }
          ],
          [
            { 
              text: 'üì± Open App', 
              web_app: { 
                url: process.env.WEBAPP_URL || process.env.FRONTEND_URL || 'https://lighthearted-phoenix-e42a4f.netlify.app'
              } 
            }
          ]
        ]
      };
      
      await this.bot.sendMessage(chatId, message, {
        reply_markup: keyboard,
        parse_mode: 'HTML'
      });
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –ø—Ä–∏—á–∏–Ω—ã
      await db.query(
        `INSERT INTO reminder_history (habit_id, sent_at, reminder_reason) 
         VALUES ($1, NOW(), $2)
         ON CONFLICT (habit_id, DATE(sent_at)) 
         DO UPDATE SET 
           sent_at = NOW(),
           reminder_reason = $2`,
        [habit.id, reason]
      );
      
      console.log(`‚úÖ Reminder sent for "${habit.title}" to user ${chatId} (reason: ${reason})`);
    } catch (error) {
      console.error(`‚ùå Failed to send reminder for habit ${habit.id}:`, error.message);
      
      if (error.response && error.response.statusCode === 403) {
        console.log(`‚ö†Ô∏è User ${habit.telegram_id} has blocked the bot`);
      }
    }
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ –ø—Ä–∏–≤—ã—á–∫–∏ —Å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º–∏ –∏ –∏—Ö —Å—Ç–∞—Ç—É—Å—ã
  async testReminder(userId, chatId) {
    try {
      console.log(`üß™ Testing reminders for user ${userId}`);
      
      const today = new Date().toISOString().split('T')[0];
      
      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–∏–≤—ã—á–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è–º–∏ –∏ –∏—Ö —Å—Ç–∞—Ç—É—Å–∞–º–∏
      const result = await db.query(
        `SELECT 
          h.id,
          h.title,
          h.goal,
          h.reminder_time,
          h.reminder_enabled,
          h.schedule_days,
          u.language,
          hm.status as today_status
         FROM habits h
         JOIN users u ON h.user_id = u.id
         LEFT JOIN habit_marks hm ON (
           hm.habit_id = h.id 
           AND hm.date = $2::date
         )
         WHERE u.id = $1
         AND h.is_active = true
         AND h.reminder_enabled = true
         ORDER BY h.reminder_time`,
        [userId, today]
      );
      
      if (result.rows.length > 0) {
        const lang = result.rows[0].language || 'en';
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–∂–¥–æ–π –ø—Ä–∏–≤—ã—á–∫–µ
        for (const habit of result.rows) {
          const timeStr = habit.reminder_time ? 
            habit.reminder_time.substring(0, 5) : '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ';
          
          const daysMap = {
            1: 'Mon', 2: 'Tue', 3: 'Wed', 
            4: 'Thu', 5: 'Fri', 6: 'Sat', 7: 'Sun'
          };
          
          const daysStr = habit.schedule_days ? 
            habit.schedule_days.map(d => daysMap[d]).join(', ') : 'Every day';
          
          const statusStr = habit.today_status || 'pending';
          let statusEmoji = '‚è∞';
          let willSendReminder = true;
          
          switch(statusStr) {
            case 'completed':
              statusEmoji = '‚úÖ';
              willSendReminder = false;
              break;
            case 'failed':
              statusEmoji = '‚ùå';
              willSendReminder = false;
              break;
            case 'skipped':
              statusEmoji = '‚è≠';
              willSendReminder = true;
              break;
            default:
              statusEmoji = '‚è∞';
              willSendReminder = true;
          }
          
          const message = lang === 'ru'
            ? `üîî <b>–¢–µ—Å—Ç–æ–≤–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>

üìù <b>–ü—Ä–∏–≤—ã—á–∫–∞:</b> ${habit.title}
üéØ <b>–¶–µ–ª—å:</b> ${habit.goal}
‚è∞ <b>–í—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:</b> ${timeStr}
üìÖ <b>–î–Ω–∏:</b> ${daysStr}
üìä <b>–°—Ç–∞—Ç—É—Å —Å–µ–≥–æ–¥–Ω—è:</b> ${statusEmoji} ${statusStr}
üîî <b>–ë—É–¥–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ:</b> ${willSendReminder ? '–î–∞ ‚úÖ' : '–ù–µ—Ç ‚ùå'}

–≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –†–µ–∞–ª—å–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≤ ${timeStr}.`
            : `üîî <b>Test Reminder</b>

üìù <b>Habit:</b> ${habit.title}
üéØ <b>Goal:</b> ${habit.goal}
‚è∞ <b>Reminder time:</b> ${timeStr}
üìÖ <b>Days:</b> ${daysStr}
üìä <b>Status today:</b> ${statusEmoji} ${statusStr}
üîî <b>Will send reminder:</b> ${willSendReminder ? 'Yes ‚úÖ' : 'No ‚ùå'}

This is a test message. Real reminders will come at ${timeStr}.`;
          
          await this.bot.sendMessage(chatId, message, {
            parse_mode: 'HTML',
            reply_markup: {
              inline_keyboard: [[
                { 
                  text: 'üì± Open App', 
                  web_app: { 
                    url: process.env.WEBAPP_URL || process.env.FRONTEND_URL
                  } 
                }
              ]]
            }
          });
          
          // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        return result.rows.length;
      } else {
        console.log('‚ùå No active habits with reminders found for user');
        return 0;
      }
    } catch (error) {
      console.error('‚ùå Test reminder failed:', error);
      return 0;
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
  async getNextReminder() {
    try {
      const now = new Date();
      const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:00`;
      const currentDay = now.getDay() || 7;
      const today = now.toISOString().split('T')[0];
      
      const result = await db.query(
        `SELECT 
          h.title,
          h.reminder_time,
          u.first_name,
          hm.status as today_status
         FROM habits h
         JOIN users u ON h.user_id = u.id
         LEFT JOIN habit_marks hm ON (
           hm.habit_id = h.id 
           AND hm.date = $3::date
         )
         WHERE h.reminder_enabled = true
         AND h.is_active = true
         AND h.reminder_time > $1
         AND $2 = ANY(h.schedule_days)
         AND (hm.status IS NULL OR hm.status IN ('pending', 'skipped'))
         ORDER BY h.reminder_time
         LIMIT 1`,
        [currentTime, currentDay, today]
      );
      
      if (result.rows.length > 0) {
        return result.rows[0];
      }
      return null;
    } catch (error) {
      console.error('Error getting next reminder:', error);
      return null;
    }
  }

  stop() {
    if (!this.isRunning) {
      console.log('‚ö†Ô∏è Reminder service is not running');
      return;
    }
    
    this.tasks.forEach(task => task.stop());
    this.tasks.clear();
    this.isRunning = false;
    console.log('üõë Reminder service stopped');
  }
}

module.exports = ReminderService;