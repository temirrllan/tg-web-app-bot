const HabitMark = require('../models/HabitMark');
const Habit = require('../models/Habit');
const db = require('../config/database');

const markController = {
  async markHabit(req, res) {
    console.log('üéØ markController.markHabit called');
    
    try {
      const { id } = req.params;
      const { status = 'completed', date } = req.body;
      const userId = req.user.id;

      console.log('Mark habit request:', {
        habitId: id,
        userId: userId,
        status: status,
        date: date
      });

      // –ï—Å–ª–∏ –¥–∞—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ–≥–æ–¥–Ω—è
      const markDate = date || new Date().toISOString().split('T')[0];
      console.log('Using date:', markDate);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–∏–≤—ã—á–∫–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      const habit = await Habit.findById(id, userId);
      if (!habit) {
        console.log('‚ùå Habit not found or access denied');
        return res.status(404).json({ 
          success: false, 
          error: 'Habit not found' 
        });
      }

      console.log('Found habit:', {
        id: habit.id,
        title: habit.title,
        user_id: habit.user_id
      });

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–º–µ—Ç–∏—Ç—å —ç—Ç—É –¥–∞—Ç—É
      const canMark = await HabitMark.canMark(markDate);
      if (!canMark) {
        console.log('‚ùå Cannot mark this date:', markDate);
        return res.status(400).json({ 
          success: false, 
          error: 'Can only mark today or yesterday' 
        });
      }

      console.log('‚úÖ Date validation passed');

      // –û—Ç–º–µ—á–∞–µ–º –ø—Ä–∏–≤—ã—á–∫—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –¥–∞—Ç—ã
      const mark = await HabitMark.mark(id, markDate, status);
      console.log('‚úÖ Habit marked successfully:', {
        habitId: id,
        date: markDate,
        status: status,
        markId: mark.id
      });

      // –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å "completed", –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥—Ä—É–∑—å—è–º
      if (status === 'completed') {
        await sendFriendNotifications(habit, userId, markDate);
      }

      res.json({
        success: true,
        mark
      });
    } catch (error) {
      console.error('üí• Mark habit error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to mark habit' 
      });
    }
  },

  async unmarkHabit(req, res) {
    console.log('üéØ markController.unmarkHabit called');
    
    try {
      const { id } = req.params;
      // –ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—É –∏–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏–ª–∏ body
      const date = req.query.date || req.body?.date || new Date().toISOString().split('T')[0];
      const userId = req.user.id;

      console.log('Unmark habit request:', {
        habitId: id,
        userId: userId,
        date: date
      });

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–∏–≤—ã—á–∫–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      const habit = await Habit.findById(id, userId);
      if (!habit) {
        console.log('‚ùå Habit not found or access denied');
        return res.status(404).json({ 
          success: false, 
          error: 'Habit not found' 
        });
      }

      const deleted = await HabitMark.deleteMark(id, date);
      console.log(deleted ? '‚úÖ Mark removed' : '‚ùå Mark not found');

      res.json({
        success: true,
        deleted,
        date: date
      });
    } catch (error) {
      console.error('üí• Unmark habit error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to unmark habit' 
      });
    }
  }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥—Ä—É–∑—å—è–º
async function sendFriendNotifications(habit, userId, markDate) {
  try {
    const bot = require('../server').bot;
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
    const userResult = await db.query(
      'SELECT first_name, username FROM users WHERE id = $1',
      [userId]
    );
    
    if (userResult.rows.length === 0) return;
    
    const userName = userResult.rows[0].first_name || userResult.rows[0].username || 'Your friend';
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ –ø—Ä–∏–≤—ã—á–∫–∏ —Å–≤—è–∑–∞–Ω—ã
    const parentHabitId = habit.parent_habit_id || habit.id;
    
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –ø—Ä–∏–≤—ã—á–µ–∫
    const membersResult = await db.query(
      `SELECT DISTINCT u.id, u.telegram_id, u.first_name, u.language
       FROM habit_members hm
       JOIN users u ON hm.user_id = u.id
       WHERE hm.habit_id IN (
         SELECT id FROM habits 
         WHERE (parent_habit_id = $1 OR id = $1)
         AND is_active = true
       )
       AND hm.is_active = true
       AND u.id != $2`,
      [parentHabitId, userId]
    );
    
    if (membersResult.rows.length === 0) return;
    
    console.log(`üì® Sending completion notifications to ${membersResult.rows.length} friends`);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–∫–æ–ª—å–∫–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –ø—Ä–∏–≤—ã—á–∫—É —Å–µ–≥–æ–¥–Ω—è
    const completedResult = await db.query(
      `SELECT COUNT(DISTINCT h.user_id) as completed_count
       FROM habits h
       JOIN habit_marks hm ON hm.habit_id = h.id
       WHERE (h.parent_habit_id = $1 OR h.id = $1)
       AND h.is_active = true
       AND hm.date = $2::date
       AND hm.status = 'completed'`,
      [parentHabitId, markDate]
    );
    
    const completedCount = parseInt(completedResult.rows[0].completed_count);
    const totalMembers = membersResult.rows.length + 1; // +1 –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    console.log(`Progress: ${completedCount}/${totalMembers} completed`);
    
    // –ï—Å–ª–∏ –≤—Å–µ –≤—ã–ø–æ–ª–Ω–∏–ª–∏ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –≤—Å–µ–º
    if (completedCount === totalMembers) {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º
      for (const member of membersResult.rows) {
        const lang = member.language || 'en';
        
        const message = lang === 'ru' 
          ? `üéâ <b>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!</b>

–í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –ø—Ä–∏–≤—ã—á–∫—É <b>"${habit.title}"</b> —Å–µ–≥–æ–¥–Ω—è!

–í—ã –º–æ–ª–æ–¥—Ü—ã! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ! üí™‚ú®`
          : `üéâ <b>Congratulations!</b>

All members completed the habit <b>"${habit.title}"</b> today!

Great job team! Keep up the amazing work! üí™‚ú®`;
        
        try {
          await bot.sendMessage(member.telegram_id, message, {
            parse_mode: 'HTML',
            reply_markup: {
              inline_keyboard: [[
                {
                  text: 'üì± Open App',
                  web_app: { 
                    url: process.env.WEBAPP_URL || process.env.FRONTEND_URL 
                  }
                }
              ]]
            }
          });
        } catch (err) {
          console.error(`Failed to send message to ${member.telegram_id}:`, err.message);
        }
        
        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–∞–º–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      const currentUserResult = await db.query(
        'SELECT telegram_id, language FROM users WHERE id = $1',
        [userId]
      );
      
      if (currentUserResult.rows.length > 0) {
        const currentUser = currentUserResult.rows[0];
        const lang = currentUser.language || 'en';
        
        const selfMessage = lang === 'ru'
          ? `üèÜ <b>–û—Ç–ª–∏—á–Ω–æ!</b>

–í—ã –∏ –≤—Å–µ –≤–∞—à–∏ –¥—Ä—É–∑—å—è –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –ø—Ä–∏–≤—ã—á–∫—É <b>"${habit.title}"</b> —Å–µ–≥–æ–¥–Ω—è!

–ö–æ–º–∞–Ω–¥–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –Ω–∞ –≤—ã—Å–æ—Ç–µ! üöÄ`
          : `üèÜ <b>Excellent!</b>

You and all your friends completed the habit <b>"${habit.title}"</b> today!

Teamwork makes the dream work! üöÄ`;
        
        try {
          await bot.sendMessage(currentUser.telegram_id, selfMessage, {
            parse_mode: 'HTML'
          });
        } catch (err) {
          console.error(`Failed to send self message:`, err.message);
        }
      }
    } else {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –æ—Å—Ç–∞–ª—å–Ω—ã–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º
      for (const member of membersResult.rows) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—ã–ø–æ–ª–Ω–∏–ª –ª–∏ —ç—Ç–æ—Ç —É—á–∞—Å—Ç–Ω–∏–∫ –ø—Ä–∏–≤—ã—á–∫—É
        const memberCompletedResult = await db.query(
          `SELECT 1 FROM habit_marks hm
           JOIN habits h ON hm.habit_id = h.id
           WHERE h.user_id = $1
           AND (h.parent_habit_id = $2 OR h.id = $2)
           AND hm.date = $3::date
           AND hm.status = 'completed'
           LIMIT 1`,
          [member.id, parentHabitId, markDate]
        );
        
        // –ï—Å–ª–∏ –¥—Ä—É–≥ —É–∂–µ –≤—ã–ø–æ–ª–Ω–∏–ª - –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        if (memberCompletedResult.rows.length > 0) continue;
        
        const lang = member.language || 'en';
        
        const message = lang === 'ru' 
          ? `üí™ <b>${userName} –≤—ã–ø–æ–ª–Ω–∏–ª(–∞) –ø—Ä–∏–≤—ã—á–∫—É!</b>

–ü—Ä–∏–≤—ã—á–∫–∞: <b>"${habit.title}"</b>

–¢–µ–ø–µ—Ä—å –≤–∞—à–∞ –æ—á–µ—Ä–µ–¥—å! –ù–µ –æ—Ç—Å—Ç–∞–≤–∞–π—Ç–µ –æ—Ç –¥—Ä—É–∑–µ–π! üî•

<i>–ü—Ä–æ–≥—Ä–µ—Å—Å: ${completedCount}/${totalMembers} –≤—ã–ø–æ–ª–Ω–∏–ª–∏</i>`
          : `üí™ <b>${userName} completed the habit!</b>

Habit: <b>"${habit.title}"</b>

Now it's your turn! Don't let your friends down! üî•

<i>Progress: ${completedCount}/${totalMembers} completed</i>`;
        
        try {
          await bot.sendMessage(member.telegram_id, message, {
            parse_mode: 'HTML',
            reply_markup: {
              inline_keyboard: [
                [
                  { 
                    text: '‚úÖ Mark as Done', 
                    callback_data: `quick_done_${habit.id}_${markDate}` 
                  }
                ],
                [
                  {
                    text: 'üì± Open App',
                    web_app: { 
                      url: process.env.WEBAPP_URL || process.env.FRONTEND_URL 
                    }
                  }
                ]
              ]
            }
          });
          
          console.log(`‚úÖ Notification sent to ${member.first_name} (${member.telegram_id})`);
        } catch (err) {
          console.error(`Failed to send message to ${member.telegram_id}:`, err.message);
        }
        
        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  } catch (error) {
    console.error('Error sending friend notifications:', error);
  }
}

module.exports = markController;
module.exports.sendFriendNotifications = sendFriendNotifications;